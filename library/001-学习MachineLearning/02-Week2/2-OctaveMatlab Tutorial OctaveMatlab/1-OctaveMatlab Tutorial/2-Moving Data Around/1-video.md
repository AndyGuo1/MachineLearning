# Octave-基本操作
## 视频
<video height=510 width=900 controls="controls" preload="none">
      <source src="amWiki/videos/001/02-Week2/2 OctaveMatlab Tutorial OctaveMatlab/2-Moving Data Around.mp4" type="video/mp4">
</video>
## 中文
在第二段关于 Octave的 辅导课视频中 我将开始介绍 如何在 Octave 中移动数据 具体来说 如果你有一个机器学习问题 你怎样把数据加载到 Octave 中？ 怎样把数据存入一个矩阵？ 如何对矩阵进行相乘？ 如何保存计算结果？ 如何移动这些数据 并用数据进行操作？ 和之前一样 这是我的 Octave 窗口 我们继续沿用上次的窗口 我键入 A 得到我们之前构建的矩阵 A 也就是用这个命令生成的 A = [1 2; 3 4; 5 6] 这是一个三行二列的矩阵 Octave 中的 size() 命令 返回矩阵的尺寸 所以 size(A) 命令返回3 2 实际上 size() 命令返回的 是一个 1×2 的矩阵 我们可以用 sz 来存放 设置 sz = size(A) 因此 sz 就是一个1×2的矩阵 第一个元素是3 第二个元素是2 所以如果键入 size(sz) 看看 sz 的尺寸 返回的是1 2 表示是一个1×2的矩阵 1 和 2 分别表示 矩阵 A 的维度 (此处口误 应为 sz 的维度 译者注) 你也可以键入 size(A, 1) 这个命令会返回 A 矩阵的第一个元素 A 矩阵的第一个维度的尺寸 也就是 A 矩阵的行数 同样 命令 size(A, 2) 将返回2 也就是 A 矩阵的列数 也就是 A 矩阵的列数 如果你有一个向量 v 假如 v = [1 2 3 4] 假如 v = [1 2 3 4] 然后键入 length(v) 这个命令将返回 最大维度的大小 你也可以键入 length(A) 由于矩阵 A 是一个3×2的矩阵 因此最大的维度 应该是3 因此该命令会返回3 但通常我们还是对向量使用 length 命令 比如 length([1;2;3;4;5]) 比如 length([1;2;3;4;5]) 而不是对矩阵使用 length 命令 因为毕竟有点容易让人弄混 下面让我们来看看 如何在系统中 加载数据和寻找数据 当我们打开 Octave 时 我们通常已经在一个 默认路径中 这个路径是 Octave 的安装位置 pwd 命令可以显示出 Octave 当前所处路径 Octave 当前所处路径 所以现在我们就在这个目录下 cd 命令 意思是改变路径 我可以把路径改为C:\Users\ang\Desktop 这样当前目录就变为了桌面 如果键入 ls ls 来自于一个 Unix 或者 Linux 命令 ls 命令将列出 我桌面上的所有路径 因此这些就是 我桌面上的所有文件了 事实上 我的桌面上 有两个文件 featuresX.dat 和 priceY.dat 是两个我想解决的机器学习问题 这是我的桌面 这是 featuresX 文件 featuresX 文件如这个窗口所示 是一个含有两列数据的文件 这其实就是我的房屋价格数据 我想应该是 数据集中有47行 第一个房子样本 面积是2104平方英尺 有3个卧室 第二套房子面积为1600 有3个卧室 等等 priceY 是这个文件 也就是 训练集中的价格数据 所以 featuresX 和 priceY 就是两个存放数据的文档 那么应该怎样把数据读入 Octave 呢？ 好的 我们只需要键 键入 featuresX.dat 这样 我将加载了 featuresX 文件 同样地我可以加载 priceY.dat 其实有好多种办法可以完成 如果你把命令写成 字符串的形式 load('featureX.dat') 也是可以的 这里打错了 这跟刚才的命令效果是相同的 只不过是把文件名 写成了一个字符串的形式 现在文件名被存在一个 字符串中 Octave 中使用引号 来表示字符串 就像这样 这就是一个字符串 因此我们读取的文件 文件名由这个字符串给出 另外 who 命令 能显示出 在我的 Octave 工作空间中的所有变量 因此 who 命令显示出 当前 Octave 储存的变量 包括 featureX 和 priceY 同样还包括 在此之前你创建的 那些变量 所以我可以键入 featuresX 回车 来显示 featuresX 这些就是存在里面的数据 还可以键入 size(featuresX) 得出的结果是 47 2 代表这是一个47×2的矩阵 类似地 输入 size(priceY) 结果是 47 1 表示这是一个47维的向量 是一个列矩阵 存放的是训练集中的所有价格 Y 的值 who 函数能让你看到 当前工作空间中的所有变量 同样还有另一个 whos 命令 能更详细地进行查看 因此 在 who 后面加一个 s 同样也列出我所有的变量 不仅如此 还列出了变量的维度 我们看到 A 是一个 3×2的矩阵 X 是一个47×2的矩阵 priceY 是一个47×1的矩阵 也就是一个向量 同时还显示出 需要占用多少内存空间 以及数据类型是什么 double 意思是双精度浮点型 这也就是说 这些数都是实数 是浮点数 如果你想删除某个变量 你可以使用 clear 命令 因此 我们键入 clear featuresX 然后再输入 whos 命令 你会发现 featuresX 消失了 另外 我们怎么储存数据呢？ 我们来看 我们设变量 v 为 priceY(1:10) 这表示的是将向量 Y 的 前10个元素存入 v 中 我们输入 who 或者 whos Y 是一个47×1的向量 因此现在 v 就是10×1的向量 因为刚才设置了 v = priceY(1:10) 这便将 v 的值 设为了 Y 的前十个元素 假如我们想把它存入硬盘 那么用 save hello.mat v 命令 这个命令 会将变量 v 存成一个叫 hello.mat 的文件 让我们回车 现在我的桌面上 就出现了一个新文件 名为 hello.mat 由于我的电脑里 也同时安装了 MATLAB 所以这个图标 上面有 MATLAB 的标识 因为操作系统把文件识别为 MATLAB 文件 所以如果在你的电脑上 图标显示的不一样的话 也没有关系 现在我们清除所有变量 直接键入 clear 这样将删除工作空间中的所有变量 所以现在工作空间中啥都没了 但如果我载入 hello.mat 文件 我又重新读取了变量 v 因为我之前 把变量 v存入了 hello.mat 文件中 所以我们刚才用 save 命令做了什么 这个命令把数据 按照二进制形式储存 或者说是更压缩的二进制形式 因此 如果 v 是很大的数据 那么压缩幅度也更大 占用空间也更小 如果你想把数据 存成一个人能看懂的形式 那么可以键入 save hello.txt v -ascii 这样就会把数据 存成一个文本文档 或者将数据的 ascii 码存成文本文档 现在 我键入了这个命令以后 我的桌面上 就有了 hello.txt 文件 就有了 hello.txt 文件 如果打开它 我们可以发现 这个文本文档存放着我们的数据 这就是读取和储存数据的方法 接下来我们再来讲讲操作数据的方法 假如 A 还是那个矩阵 跟刚才一样还是那个 3×2 的矩阵 现在我们加上索引值 比如键入 A(3,2) 这将索引到 A 矩阵的 (3,2) 元素 A 矩阵的 (3,2) 元素 这就是我们通常 书写矩阵的形式 写成 A 下标32 下标32  3和2分别表示 矩阵的第三行 和第二列对应的元素 因此也就对应 6 我也可以键入 A(2,:) 来返回 第二列的所有元素 因此 冒号表示 该行或该列的所有元素 因此 A(2,:) 表示 A 矩阵的第二行的所有元素 类似地 如果我键入 A(:,2) 这将返回 A 矩阵第二列的所有元素 这将得到 2 4 6 这表示返回 A 矩阵的第二列的所有元素 因此这就是 矩阵 A 的第二列 就是 2 4 6 你也可以在运算中 使用这些较为复杂的索引 我再给你展示几个例子 可能你也不会经常使用 但我还是输入给你看 A([1 3],:) 这个命令意思是 取 A 矩阵第一个索引值为1或3的元素 也就是说我取的是 A 矩阵的第一行和 第三行的每一列 第三行的每一列 这是 A 矩阵 因此 输入 A([1 3], :) 返回第一行 返回第三行 冒号表示的是 取这两行的每一列元素 也就是第一行 和第二行的所有元素(此处口误 应为第三行 译者注) 因此返回结果为 1 2 5 6 可能这些比较复杂一点的 索引操作 你不会经常用到 我们还能做什么呢 这依然是 A 矩阵 A(:,2) 命令返回第二列 你也可以为它赋值 所以我可以取 A 矩阵的第二列 然后将它赋值为 10 11 12 如果我这样做的话 我实际上是取出了 A 的第二列 然后把一个列向量[10;11;12]赋给了它 因此现在 A 矩阵的第一列还是 1 3 5 第二列就被替换为 10 11 12 接下来一个操作 让我们把 A 设为 A = [A, [100, 101, 102]] 这样做的结果是 在原矩阵的右边 附加了一个新的列矩阵 附加了一个新的列矩阵 现在 见证奇迹的时刻... 噢 我又犯错了 应该放分号的 现在 A 矩阵就是这样了 明白? 我希望你听懂了 所以 [100;101;102] 这是个列矩阵 而我们所做的 就是把 A 矩阵设置为 原来的 A 矩阵 再在右边附上一个 新添加的列矩阵 我们的原矩阵 A 就是右边这个6个元素 就是右边这个6个元素 所以我们就是把 A 矩阵 右边加上了一个 新的列向量 所以现在 A 矩阵 变成这样一个 3×3 的矩阵 最后 还有一个小技巧 我也经常使用 如果你就输入 A(:) 这是一个很特别的语法结构 意思是把 A 中的所有元素 放入一个单独的列向量 这样我们就得到了一个 9×1 的向量 这些元素都是 A 中的元素排列起来的 再来几个例子好了 我还是把 A 重新设为 [1 2; 3 4; 5 6] 假如说 我再设一个 B 为[11 12; 13 14; 15 16] 我可以新建一个矩阵 C C = [A B] 这个意思就是 这是我的矩阵 A 这是我的矩阵 B 我设 C = [A B] 这样做的结果就是 把这两个矩阵直接连在一起 矩阵 A 在左边 矩阵 B 在右边 这样组成了 C 矩阵 就是直接把 A 和 B 合起来 我还可以设 C = [A; B] 这里的分号表示 把分号后面的东西放到下面 所以 [A; B]的作用 依然还是把两个矩阵 放在一起 只不过现在是上下排列 所以现在 A 在上面 B 在下面 C 就是一个 6×2 矩阵 简单地说 分号的意思就是换到下一行 所以 C 就包括上面的 A 然后换行到下面 然后在下面放上一个 B 另外顺便说一下 这个[A B]命令 跟 [A, B] 是一样的 这两种写法的结果是相同的 好了 通过以上这些操作 希望你现在掌握了 怎样构建矩阵 也希望我展示的这些命令 能让你很快地学会 怎样把矩阵放到一起 怎样取出矩阵 并且把它们放到一起 组成更大的矩阵 通过几句简单的代码 Octave 能够很方便地 很快速地帮助我们 组合复杂的矩阵以及对数据进行移动 这就是移动数据这一节课 在下一段视频中 我们将一起来谈谈 怎样利用数据进行更为复杂的计算 希望这节课的内容 能让你明白 在 Octave 中 怎样用几句简单的命令 很快地对数据进行移动 包括加载和储存一个向量 或矩阵 加载和存储数据 把矩阵放在一起 构建更大的矩阵 用索引对矩阵某个特定元素进行操作等等 我知道可能我一下子 讲了很多命令 所以我认为对你来讲 最好的学习方法是 下课后复习一下我键入的这些代码 好好地看一看 从课程的网上 把代码的副本下载下来 重新好好看看这些副本 然后自己在 Octave 中 把这些命令重新输一遍 慢慢开始学会使用这些命令 当然 没有必要把这些命令都记住 你也不可能记得住 你要做的就是 从这段视频里 了解一下你可以用哪些命令 做哪些事 这样在你今后需要 编写学习算法时 如果你要找到某个 Octave 中的命令 你可能回想起 你之前在这里学到过 然后你就可以查找 课程中提供的程序副本 这样就能很轻松地找到 你想使用的命令了 基本用不上 移动数据这节课的全部内容 在下一段视频中 我将开始向你介绍 怎样进行一些 更复杂的计算 怎样对数据进行计算 怎样对数据进行计算 同时开始实现学习算法
## English
In this second tutorial video on Octave, I'd like to start to tell you how to move data around in Octave. So, if you have data for a machine learning problem, how do you load that data in Octave? How do you put it into matrix? How do you manipulate these matrices? How do you save the results? How do you move data around and operate with data? Here's my Octave window as before, picking up from where we left off in the last video. If I type A, that's the matrix so we generate it, right, with this command equals one, two, three, four, five, six, and this is a three by two matrix. The size command in Octave lets you, tells you what is the size of a matrix. So size A returns three, two. It turns out that this size command itself is actually returning a one by two matrix. So you can actually set SZ equals size of A and SZ is now a one by two matrix where the first element of this is three, and the second element of this is two. So, if you just type size of SZ. Does SZ is a one by two matrix whose two elements contain the dimensions of the matrix A. You can also type size A one to give you back the first dimension of A, size of the first dimension of A. So that's the number of rows and size A two to give you back two, which is the number of columns in the matrix A. If you have a vector V, so let's say V equals one, two, three, four, and you type length V. What this does is it gives you the size of the longest dimension. So you can also type length A and because A is a three by two matrix, the longer dimension is of size three, so this should print out three. But usually we apply length only to vectors. So you know, length one, two, three, four, five, rather than apply length to matrices because that's a little more confusing. Now, let's look at how the load data and find data on the file system. When we start an Octave we're usually, we're often in a path that is, you know, the location of where the Octave location is. So the PWD command shows the current directory, or the current path that Octave is in. So right now we're in this maybe somewhat off scale directory. The CD command stands for change directory, so I can go to C:/Users/Ang/Desktop, and now I'm in, you know, in my Desktop and if I type ls, ls is, it comes from a Unix or a Linux command. But, ls will list the directories on my desktop and so these are the files that are on my Desktop right now.In fact, on my desktop are two files: Features X and Price Y that's maybe come from a machine learning problem I want to solve. So, here's my desktop. Here's Features X, and Features X is this window, excuse me, is this file with two columns of data. This is actually my housing prices data. So I think, you know, I think I have forty-seven rows in this data set. And so the first house has size two hundred four square feet, has three bedrooms; second house has sixteen hundred square feet, has three bedrooms; and so on. And Price Y is this file that has the prices of the data in my training set. So, Features X and Price Y are just text files with my data. How do I load this data into Octave? Well, I just type the command load Features X dot dat and if I do that, I load the Features X and can load Price Y dot dat. And by the way, there are multiple ways to do this. This command if you put Features X dot dat on that in strings and load it like so. This is a typo there. This is an equivalent command. So you can, this way I'm just putting the file name of the string in the founding in a string and in an Octave use single quotes to represent strings, like so. So that's a string, and we can load the file whose name is given by that string. Now the WHO command now shows me what variables I have in my Octave workspace. So Who shows me whether the variables that Octave has in memory currently. Features X and Price Y are among them, as well as the variables that, you know, we created earlier in this session. So I can type Features X to display features X. And there's my data. And I can type size features X and that's my 47 by two matrix. And some of these size, press Y, that gives me my 47 by one vector. This is a 47 dimensional vector. This is all common vector that has all the prices Y in my training set. Now the who function shows you one of the variables that, in the current workspace. There's also the who S variable that gives you the detailed view. And so this also, with an S at the end this also lists my variables except that it now lists the sizes as well. So A is a three by two matrix and features X as a 47 by 2 matrix. Price Y is a 47 by one matrix. Meaning this is just a vector. And it shows, you know, how many bytes of memory it's taking up. As well as what type of data this is. Double means double position floating point so that just means that these are real values, the floating point numbers. Now if you want to get rid of a variable you can use the clear command. So clear features X and type whose again. You notice that the features X variable has now disappeared. And how do we save data? Let's see. Let's take the variable V and say that it's a price Y 1 colon 10. This sets V to be the first 10 elements of vector Y. So let's type who or whose. Whereas Y was a 47 by 1 vector. V is now 10 by 1. B equals price Y, one column ten that sets it to the just the first ten elements of Y. Let's say I wanna save this to date to disc the command save, hello.mat V. This will save the variable V into a file called hello.mat. So let's do that. And now a file has appeared on my Desktop, you know, called Hello.mat. I happen to have MATLAB installed in this window, which is why, you know, this icon looks like this because Windows is recognized as it's a MATLAB file,but don't worry about it if this file looks like it has a different icon on your machine and let's say I clear all my variables. So, if you type clear without anything then this actually deletes all of the variables in your workspace. So there's now nothing left in the workspace. And if I load hello.mat, I can now load back my variable v, which is the data that I previously saved into the hello.mat file. So, hello.mat, what we did just now to save hello.mat to view, this save the data in a binary format, a somewhat more compressed binary format. So if v is a lot of data, this, you know, will be somewhat more compressing. Will take off less the space. If you want to save your data in a human readable format then you type save hello.text the variable v and then -ascii. So, this will save it as a text or as ascii format of text. And now, once I've done that, I have this file. Hello.text has just appeared on my desktop, and if I open this up, we see that this is a text file with my data saved away. So that's how you load and save data. Now let's talk a bit about how to manipulate data. Let's set a equals to that matrix again so is my three by two matrix. So as indexing. So type A 3, 2. This indexes into the 3, 2 elements of the matrix A. So, this is what, you know, in normally, we will write this as a subscript 3, 2 or A subscript,you know, 3, 2 and so that's the element and third row and second column of A which is the element of six. I can also type A to comma colon to fetch everything in the second row. So, the colon means every element along that row or column. So, a of 2 comma colon is this second row of a. Right. And similarly, if I do a colon comma 2 then this means get everything in the second column of A. So, this gives me 2 4 6. Right this means of A. everything, second column. So, this is my second column A, which is 2 4 6. Now, you can also use somewhat most of the sophisticated index in the operations. So So, we just click each of an example. You do this maybe less often, but let me do this A 1 3 comma colon. This means get all of the elements of A who's first indexes one or three. This means I get everything from the first and third rows of A and from all columns. So, this was the matrix A and so A 1 3 comma colon means get everything from the first row and from the second row and from the third row and the colon means, you know, one both of first and the second columns and so this gives me this 1 2 5 6. Although, you use the source of more subscript index operations maybe somewhat less often. To show you what else we can do. Here's the A matrix and this source A colon, to give me the second column. You can also use this to do assignments. So I can take the second column of A and assign that to 10, 11, 12, and if I do that I'm now, you know, taking the second column of a and I'm assigning this column vector 10, 11, 12 to it. So, now a is this matrix that's 1, 3, 5. And the second column has been replaced by 10, 11, 12. And here's another operation. Let's set A to be equal to A comma 100, 101, 102 like so and what this will do is depend another column vector to the right. So, now, oops. I think I made a little mistake. Should have put semicolons there and now A is equals to this. Okay? I hope that makes sense. So this 100, 101, 102. This is a column vector and what we did was we set A, take A and set it to the original definition. And then we put that column vector to the right and so, we ended up taking the matrix A and--which was these six elements on the left. So we took matrix A and we appended another column vector to the right; which is now why A is a three by three matrix that looks like that. And finally, one neat trick that I sometimes use if you do just a and just a colon like so. This is a somewhat special case syntax. What this means is that put all elements with A into a single column vector and this gives me a 9 by 1 vector. They adjust the other ones are combined together.Just a couple more examples. Let's see. Let's say I set A to be equal to 123456, okay? And let's say I set a B to B equal to 11, 12, 13, 14, 15, 16. I can create a new matrix C as A B. This just means my Matrix A. Here's my Matrix B and I've set C to be equal to AB. What I'm doing is I'm taking these two matrices and just concatenating onto each other. So the left, matrix A on the left. And I have the matrix B on the right. And that's how I formed this matrix C by putting them together. I can also do C equals A semicolon B. The semi colon notation means that I go put the next thing at the bottom. So, I'll do is a equals semicolon B. It also puts the matrices A and B together except that it now puts them on top of each other. so now I have A on top and B at the bottom and C here is now in 6 by 2 matrix. So, just say the semicolon thing usually means, you know, go to the next line. So, C is comprised by a and then go to the bottom of that and then put b in the bottom and by the way, this A B is the same as A, B and so you know, either of these gives you the same result.So, with that, hopefully you now know how to construct matrices and hopefully starts to show you some of the commands that you use to quickly put together matrices and take matrices and, you know, slam them together to form bigger matrices, and with just a few lines of code, Octave is very convenient in terms of how quickly we can assemble complex matrices and move data around. So that's it for moving data around. In the next video we'll start to talk about how to actually do complex computations on this, on our data. So, hopefully that gives you a sense of how, with just a few commands, you can very quickly move data around in Octave. You know, you load and save vectors and matrices, load and save data, put together matrices to create bigger matrices, index into or select specific elements on the matrices. I know I went through a lot of commands, so I think the best thing for you to do is afterward, to look at the transcript of the things I was typing. You know, look at it. Look at the coursework site and download the transcript of the session from there and look through the transcript and type some of those commands into Octave yourself and start to play with these commands and get it to work. And obviously, you know, there's no point at all to try to memorize all these commands. It's just, but what you should do is, hopefully from this video you have gotten a sense of the sorts of things you can do. So that when later on when you are trying to program a learning algorithms yourself, if you are trying to find a specific command that maybe you think Octave can do because you think you might have seen it here, you should refer to the transcript of the session and look through that in order to find the commands you wanna use. So, that's it for moving data around and in the next video what I'd like to do is start to tell you how to actually do complex computations on our data, and how to compute on the data, and actually start to implement learning algorithms.
